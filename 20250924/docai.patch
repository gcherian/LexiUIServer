// src/lib/docai.js
function flatten(obj, prefix = "", out = []) {
  if (obj == null) return out;
  if (Array.isArray(obj)) {
    obj.forEach((v, i) => flatten(v, `${prefix}[${i}]`, out));
    return out;
  }
  if (typeof obj === "object") {
    Object.entries(obj).forEach(([k, v]) => {
      const path = prefix ? `${prefix}.${k}` : k;
      if (v && typeof v === "object" && !Array.isArray(v)) {
        flatten(v, path, out);
      } else {
        out.push({ key: path, value: v == null ? "" : String(v) });
      }
    });
    return out;
  }
  out.push({ key: prefix || "(value)", value: String(obj) });
  return out;
}

/**
 * Parse your DocAI output into a flat KV list for the left pane.
 * Supports:
 * - documents.properties[0]  (your metadata map)
 * - document.pages[].formFields[]
 * - document.entities[] (+ properties)
 * - keyValuePairs[]
 * - document.metadata (fallback)
 */
export function parseDocAIToKV(doc) {
  const kvs = [];
  const root = doc.document || doc.documents || doc;

  // (A) Your metadata map: documents.properties[0]
  const propsArr = root?.properties;
  if (Array.isArray(propsArr) && propsArr.length && typeof propsArr[0] === "object") {
    kvs.push(...flatten(propsArr[0]));
  }

  // (B) Standard DocAI formFields (if present)
  (root.pages || []).forEach(p =>
    (p.formFields || []).forEach(ff => {
      const k = ff.fieldName?.text || ff.fieldName?.content || "";
      const v = ff.fieldValue?.text || ff.fieldValue?.content || "";
      if (k || v) kvs.push({ key: k, value: v });
    })
  );

  // (C) Entities + properties (invoice/receipt parsers)
  (root.entities || []).forEach(e => {
    const val = e.mentionText || e.normalizedValue?.text || "";
    if (e.type && val) kvs.push({ key: e.type, value: val });
    (e.properties || []).forEach(p => {
      const k = [e.type, p.type].filter(Boolean).join(".");
      const v = p.mentionText || p.normalizedValue?.text || "";
      if (v) kvs.push({ key: k, value: v });
    });
  });

  // (D) Generic keyValuePairs[]
  (root.keyValuePairs || doc.keyValuePairs || []).forEach(kvp => {
    const k = kvp.key?.text || kvp.key?.content || "";
    const v = kvp.value?.text || kvp.value?.content || "";
    if (k || v) kvs.push({ key: k, value: v });
  });

  // (E) document.metadata/fallback
  const meta = root.metadata || doc.metadata;
  if (meta && typeof meta === "object") {
    Object.entries(meta).forEach(([k, v]) => {
      kvs.push({ key: k, value: typeof v === "string" ? v : JSON.stringify(v) });
    });
  }

  // Deduplicate
  const seen = new Set();
  return kvs.filter(({ key, value }) => {
    const s = key + "::" + value;
    if (seen.has(s)) return false;
    seen.add(s);
    return true;
  });
}

//tolerant
// src/lib/docai.js

function flatObjectEntries(obj, prefix = "", out = []) {
  if (!obj || typeof obj !== "object") return out;
  for (const [k, v] of Object.entries(obj)) {
    const path = prefix ? `${prefix}.${k}` : k;
    if (v && typeof v === "object" && !Array.isArray(v)) {
      flatObjectEntries(v, path, out);
    } else {
      out.push({ key: path, value: v == null ? "" : String(v) });
    }
  }
  return out;
}

// Heuristic: is this a "metadata map" object (mostly scalar values)?
function looksLikeMetaMap(o) {
  if (!o || typeof o !== "object" || Array.isArray(o)) return false;
  const entries = Object.entries(o);
  if (entries.length < 3) return false;
  let scalar = 0;
  for (const [, v] of entries) {
    if (v == null) continue;
    const t = typeof v;
    if (t === "string" || t === "number" || t === "boolean") scalar++;
  }
  return scalar >= Math.max(3, Math.floor(entries.length * 0.6));
}

export function parseDocAIToKV(raw) {
  const kvs = [];
  const root = raw.document || raw.documents || raw;

  // (A) Your format: { documents: { properties: [ {...} ], pages:[...] } }
  if (root?.properties && Array.isArray(root.properties) && root.properties.length) {
    const p0 = root.properties[0];
    if (p0 && typeof p0 === "object") {
      // If there's an obvious "metaDataMap" / "metadataMap" object inside, prefer that
      const md = p0.metaDataMap || p0.metadataMap || p0.metadata || null;
      if (md && looksLikeMetaMap(md)) {
        for (const [k, v] of Object.entries(md)) {
          kvs.push({ key: k, value: v == null ? "" : String(v) });
        }
      } else if (looksLikeMetaMap(p0)) {
        for (const [k, v] of Object.entries(p0)) {
          kvs.push({ key: k, value: v == null ? "" : String(v) });
        }
      } else {
        // fallback: flatten entire properties[0]
        kvs.push(...flatObjectEntries(p0));
      }
    }
  }

  // (B) Standard DocAI formFields (if present)
  (root.pages || []).forEach(p =>
    (p.formFields || []).forEach(ff => {
      const k = ff.fieldName?.text || ff.fieldName?.content || "";
      const v = ff.fieldValue?.text || ff.fieldValue?.content || "";
      if (k || v) kvs.push({ key: k, value: v });
    })
  );

  // (C) Entities + properties
  (root.entities || []).forEach(e => {
    const val = e.mentionText || e.normalizedValue?.text || "";
    if (e.type && val) kvs.push({ key: e.type, value: val });
    (e.properties || []).forEach(p => {
      const k = [e.type, p.type].filter(Boolean).join(".");
      const v = p.mentionText || p.normalizedValue?.text || "";
      if (v) kvs.push({ key: k, value: v });
    });
  });

  // (D) Generic keyValuePairs[]
  (root.keyValuePairs || raw.keyValuePairs || []).forEach(kvp => {
    const k = kvp.key?.text || kvp.key?.content || "";
    const v = kvp.value?.text || kvp.value?.content || "";
    if (k || v) kvs.push({ key: k, value: v });
  });

  // (E) Root-level metadata as a last resort
  const meta = root.metadata || raw.metadata;
  if (meta && looksLikeMetaMap(meta)) {
    for (const [k, v] of Object.entries(meta)) {
      kvs.push({ key: k, value: v == null ? "" : String(v) });
    }
  }

  // De-dupe
  const seen = new Set();
  const out = kvs.filter(({ key, value }) => {
    const s = key + "::" + value;
    if (seen.has(s)) return false;
    seen.add(s);
    return true;
  });

  // Debug: show what we found
  // eslint-disable-next-line no-console
  console.log(`[DocAI] Parsed ${out.length} fields`, out.slice(0, 10));
  return out;
}

//app
	
// src/App.jsx
import React, { useRef, useState } from "react";
import KVPane from "./components/KVPane.jsx";
import PdfPane from "./components/PdfPane.jsx";
import { parseDocAIToKV } from "./lib/docai.js";
import "./style.css";

export default function App() {
  const [pdfUrl, setPdfUrl] = useState("");
  const [kvs, setKvs] = useState([]);
  const pdfRef = useRef(null);

  async function onUploadPdf(e) {
    const f = e.target.files?.[0];
    if (!f) return;
    setPdfUrl(URL.createObjectURL(f));
    e.target.value = ""; // allow re-upload of same file
  }

  async function onUploadDocAI(e) {
    const f = e.target.files?.[0];
    if (!f) return;
    try {
      const json = JSON.parse(await f.text());
      const parsed = parseDocAIToKV(json);
      setKvs(parsed);
      // eslint-disable-next-line no-alert
      if (!parsed.length) alert("No fields found in this JSON. Check console for structure.");
      console.log("Raw JSON root keys:", Object.keys(json || {}));
    } catch (err) {
      console.error("Invalid JSON:", err);
      alert("Invalid JSON file.");
    } finally {
      e.target.value = ""; // allow re-upload of same file
    }
  }

  function onLocate(valueStr) {
    pdfRef.current?.locateValue(valueStr);
  }

  return (
    <div className="app">
      <div className="topbar">
        <div className="brand">DocAI KV Highlighter</div>
        <div className="toolbar">
          <span style={{opacity:.8,marginRight:8}}>{kvs.length ? `${kvs.length} fields` : "Upload a DocAI JSON"}</span>
          <label className="btn">
            <input type="file" accept="application/pdf" onChange={onUploadPdf} />
            Choose PDF
          </label>
          <label className="btn">
            <input type="file" accept="application/json" onChange={onUploadDocAI} />
            Choose DocAI JSON
          </label>
        </div>
      </div>

      <div className="split">
        <KVPane kvs={kvs} onPick={onLocate} />
        <PdfPane ref={pdfRef} pdfUrl={pdfUrl} />
      </div>
    </div>
  );
}

//KV

// in KVPane.jsx row renderer
<tr onClick={()=>onPick(r.value)} style={{cursor:"pointer"}}>
  <td><code style={{pointerEvents:"none"}}>{r.key}</code></td>
  <td>{r.value}</td>
</tr>




